module Fa12

use dataTypes.DataTypes
use string.String
use int.Int
use option.Option
(* use seq.Seq *)
(*
  address_from : address
  address_to : address
  value : nat
  address_from * (address_to * value)
*)

exception Failwith string

val failwith (s: string) : 'a
  raises  { Failwith }
  ensures { false }

type transfer =
{
  address_from : string;
  address_to : string;
  value_of_transfer : int;
}
invariant { value_of_transfer >=0 }

(*
  spender : address
  value : nat
  address_sender * value
*)
type approve_t =
{
  spender : string;
  value_for_approval : int;
}
invariant { value_for_approval >=0 }

(*
  owner : address
  spender : address
  address_owner * address_spender
*)
type allowance_key =
{
  owner_of_key : string;
  spender_of_key : string;
}

(*
  request : allowance_key
  callback : nat contract
  (address_owner * address_spender) * (nat contract)
*)
type getAllowance =
{
  request_alw : allowance_key;
  callback_alw : string;
  (*FIXME: callback : nat contract  *)
}
(*
  owner : address
  callback : nat contract
  address_owner * (nat contract)
*)
type getBalance =
{
  owner_of_blc : string;
  callback_blc : string;
  (*FIXME: callback : nat contract  *)
}
(*
  request : unit
  callback : nat contract
  address_owner * (nat contract)
*)
type getTotalSupply =
{
  request_tsp : unit;
  callback_tsp : string;
  (*FIXME: callback : nat contract  *)
}

clone import myMap.MyMap as Token_map with type key = string

clone import myMap.MyMap as Allowance_map with type key = allowance_key

type tokens = Token_map.t int

type allowances = Allowance_map.t int

type storage = {
  tokens : tokens;
  allowances : allowances;
  total_supply : int;
}
invariant { total_supply >= 0 }

type parameter =
  | Transfer transfer
  | Approve approve_t
  | GetAllowance getAllowance
  | GetBalance getBalance
  | GetTotalSupply getTotalSupply

type result =
{
  op_list: list operation;
  strg : storage;
}

(* contract functions *)

val tezos_transaction (v: int) (m: int) (c: string) (* ? *) : list operation
val tezos_get_sender (_: unit) : string



let is_nat (i: int) : option int =
  if i < 0 then None
  else Some i  


val transfer (param : transfer) (storage : storage) : result
  (* let allowances = storage.allowances in
  let tokens = storage.tokens in
  let allowances = (* TODO: check not sure *)
    if tezos_get_sender () = param.address_from then allowances
    else 
      let allowance_key = { owner_of_key = param.address_from;
                            spender_of_key = tezos_get_sender () } in
      let authorized_value =
      match allowances allowance_key with
      | Some value -> value
      | None -> 0
      end in
      let authorized_value =
        match is_nat (authorized_value - param.value_of_transfer) with
        | None -> absurd (*(failwith "NotEnoughAllowance" : nat)*)
        | Some authorized_value -> authorized_value
        end in
        (* TODO: change allowance_key (positive_opt authorized_value) allowances *)
        allowances in
  let tokens =
    let from_balance =
      match param *)

(*FIXME: name approve is already in context *)
let approve (param : approve_t) (storage : storage) : result
  raises { Failwith }
= let allowances = storage.allowances in
  let allowance_key = { owner_of_key = tezos_get_sender ();
                        spender_of_key = param.spender } in
  let previous_value =
    match Allowance_map.find_opt allowance_key allowances with
    | Some value -> value
    | None -> 0
    end in
  begin
    if previous_value > 0 && param.value_for_approval > 0
    then failwith "UnsafeAllowanceChange"
    else ();    
    let allowances = Allowance_map.add allowance_key param.value_for_approval allowances in 
     { op_list = Nil; strg = { storage with allowances = allowances }} 
  end

let getAllowance (param : getAllowance) (storage : storage) : list operation
= let value =
    match Allowance_map.find_opt param.request_alw storage.allowances with
    | Some value -> value
    | None -> 0 end in
  tezos_transaction value 0 param.callback_alw

let getBalance (param : getBalance) (storage : storage) : list operation
= let value =
    match Token_map.find_opt param.owner_of_blc storage.tokens with
    | Some value -> value
    | None -> 0
    end in
  tezos_transaction value 0 param.callback_blc

let getTotalSupply (param : getTotalSupply) (storage : storage) : list operation
= let total = storage.total_supply in
  tezos_transaction total 0 param.callback_tsp

let main (param : parameter) (storage : storage) : result
  raises { Failwith }
=
  match param with
    | Transfer param -> transfer param storage
    | Approve param -> approve param storage
    | GetAllowance param ->
        let i = getAllowance param storage in
        { op_list = i; strg = storage}
    | GetBalance param ->
        let i = getBalance param storage in
        { op_list = i; strg = storage}
    | GetTotalSupply param ->
        let i = getTotalSupply param storage in
        { op_list = i; strg = storage}
  end

end
